/**
Copyright (c)
Audi Autonomous Driving Cup. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3.  All advertising materials mentioning features or use of this software must display the following acknowledgement: �This product includes software developed by the Audi AG and its contributors for Audi Autonomous Driving Cup.�
4.  Neither the name of Audi nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY AUDI AG AND CONTRIBUTORS �AS IS� AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL AUDI AG OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


**********************************************************************
* $Author:: spiesra $  $Date:: 2015-05-13 08:29:07#$ $Rev:: 35003   $
**********************************************************************/

#ifndef _MARKERDETECTFILTER_HEADER
#define _MARKERDETECTFILTER_HEADER

/*!
This filter searches for Aruco markers in the given frame on the input video pin. It uses mainly the Aruco lib to find the markers and get the marker Id and their additional parameters and mark them optionally in the video frame. If one or more markers are detected in the frame samples on the pins RoadSign and RoadSign_ext are generated containing the parameters of the sign.
The samples of the pin RoadSign include the marker identifier and the image size of the marker. The samples of the pint RoadSign_ext include the marker identifier, the image size of the marker and the rotation and translation vector. For further description of the samples refer to chapter 3.5.

For the calculation of the rotation and translation vector the intrinsic parameters of the camera has to be known. These parameters can be get with the camera calibration filter and the calibration file generated by that filter loaded with in the  property Calibration File for used Camera.
For the correct assignment of the marker IDs the dictionary file has to be set in the properties as well. The dictionary file includes the assignment of the bit codes of the markers to the predefined ID and has the following content:
%YAML:1.0
nmarkers: 12
markersize: 3
marker_0: "010010111"
marker_1: "001100010"
marker_2: "001001111"
marker_3: "110011101"
marker_4: "011001010"
marker_5: "110101111"
marker_6: "000111101"
marker_7: "011101000"
marker_8: "001010101"
marker_9: "010011001"
marker_10: "110011010"
marker_11: "010010100"

The IDs are mapped to the signs as the following table shows:
 MARKER_ID_UNMARKEDINTERSECTION	0
 MARKER_ID_STOPANDGIVEWAY	1
 MARKER_ID_PARKINGAREA	2
 MARKER_ID_HAVEWAY	3
 MARKER_ID_AHEADONLY	4
 MARKER_ID_GIVEWAY	5
 MARKER_ID_PEDESTRIANCROSSING	6
 MARKER_ID_ROUNDABOUT	7
 MARKER_ID_NOOVERTAKING	8
 MARKER_ID_NOENTRYVEHICULARTRAFFIC	9
 MARKER_ID_ONEWAYSTREET 	0

The named are enums are also contained in the file aadc_roadSign_enums.h in src\aadcDemo\include\aadc_roadSign_enums.h .
*/

#include "stdafx.h"
#include <math.h>
#include <Logger.h>
#include "../htwk_structs/tReadyModule.h"
#include "../htwk_structs/tRoadSign.h"

#define OID "htwk.markerDetection"
#define FILTER_NAME "HTWK Marker Detection"

class MarkerDetection : public cFilter
{
    ADTF_FILTER(OID, FILTER_NAME, OBJCAT_DataFilter);
    public:

        MarkerDetection(const tChar *__info);

        virtual ~MarkerDetection();

        tResult Init(tInitStage eStage, __exception);

        tResult OnPinEvent(adtf::IPin *pSource, tInt nEventCode, tInt nParam1, tInt nParam2,
                           adtf::IMediaSample *pMediaSample);

    protected:
        Logger logger;

        cInputPin getReadyInput;
        cOutputPin readyOutput;

        /*! input Pin for video */
        cVideoPin m_oPinInputVideo;
        /*! output Pin for video */
        cVideoPin m_oPinOutputVideo;
        /*! output Pin for detected Sign as tInt */
        cOutputPin m_oPinRoadSign;
        /*! output Pin for detected Sign as tInt with extended information */
        cOutputPin m_oPinRoadSignExt;

        /*!  */
        UCOM_DECLARE_TIMING_SPOT(m_oProcessStart)
        /*!  */
        UCOM_DECLARE_TIMING_SPOT(m_oProcessEnd)

    private:
        /*! bitmapformat of input image */
        tBitmapFormat m_sInputFormat;

        /*! bitmapformat of output image */
        tBitmapFormat m_sOutputFormat;

        /*! indicates wheter information is printed to the console or not */
        tBool m_bDebugModeEnabled;

        /*! indicates wheter the camara parameters are loaded or not */
        tBool m_bCamaraParamsLoaded;

        /*! indicates what is transmitted over the output pin*/
        tInt m_iOutputMode;


        cObjectPtr<IMediaType> roadSignMediaType;
        cObjectPtr<IMediaTypeDescription> roadSignDescription;

        cObjectPtr<IMediaType> roadSignExtMediaType;
        cObjectPtr<IMediaTypeDescription> roadSignExtDescription;

        cObjectPtr<IMediaType> enumMediaType;
        cObjectPtr<IMediaTypeDescription> enumDescription;

        /*! function process the video data
        @param pSample the new media sample to be processed
        */
        tResult ProcessVideo(IMediaSample *pSample);

        /*! function to set the m_sProcessFormat and the  m_sInputFormat variables
        @param pFormat the new format for the input and input pin
        */
        tResult UpdateInputImageFormat(const tBitmapFormat *pFormat);

        /*! function to set the m_output image format
        @param pFormat the new format for the output pin
        */
        tResult UpdateOutputImageFormat(const tBitmapFormat *pFormat);

        /*! function to transmit a detected road sign
        @param i16ID ID of the sign
        @param f32MarkerSize size of the markers sides in meters
        @param timeOfFrame the timestamp of the frame where the sign was detected
        */
        tResult sendRoadSignStruct(const tInt16 &i16ID, const tFloat32 &f32MarkerSize, const tTimeStamp &timeOfFrame);

        /*! function to transmit a detected road sign with extedend info
        @param i16ID ID of the sign
        @param f32MarkerSize size of the markers sides in meters
        @param timeOfFrame the timestamp of the frame where the sign was detected
        @param Tvec the translation vector
        @param Rvec the rotation vector
        */
        tResult sendRoadSignStructExt(const tInt16 &i16ID, const tFloat32 &f32MarkerSize, const tTimeStamp &timeOfFrame,
                                      const Mat &Tvec, const Mat &Rvec);

        /*! the aruco elements: */
        /*! the aruco detector for the markers*/
        MarkerDetector m_MDetector;
        /*! the aruco markers */
        vector<Marker> m_TheMarkers;
        /*! size of the markers*/
        tFloat32 m_f32MarkerSize;
        /*! the intrinsic parameter of the camera*/
        CameraParameters m_TheCameraParameters;
        /*! the dictionary for the aruco lib*/
        Dictionary m_Dictionary;

        cv::Mat m_Intrinsics;
        cv::Mat m_Distorsion;

    private:
        tResult CreateDescriptions(IException **__exception_ptr);

        tResult CreateInputPins(IException **__exception_ptr);

        tResult CreateOutputPins(IException **__exception_ptr);


        tResult SendEnum(cOutputPin &pin, tInt value);
};

#endif //_MARKERDETECTFILTER_HEADER
